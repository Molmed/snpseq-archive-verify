import logging
import re
import rq
import subprocess
import os
import datetime

log = logging.getLogger(__name__)

def _parse_dsmc_return_code(exit_code, output, whitelist):
    """
    Parses the dsmc output when we've encountered a non-zero exit code. For some certain exit codes, 
    warnings and errors we still want to return successfully. 

    :param exit_code: The exit code recieved from the failing dsmc process
    :param output: The text output from the dsmc process
    :param whitelist: A list of whitelisted warnings
    :returns True if only whitelisted warnings was encountered in the output, otherwise False
    """
    log.debug("DSMC process returned an error!")

    # DSMC sets return code to 8 when a warning was encountered.
    if exit_code == 8:
        log.debug("DSMC process actually returned a warning.")

        output = output.splitlines()

        # Search through the DSMC log and see if we only have
        # whitelisted warnings. If that is the case, change the
        # return code to 0 instead. Otherwise keep the error state.
        warnings = []

        for line in output:
            matches = re.findall(r'ANS[0-9]+W', line)

            for match in matches:
                warnings.append(match)

        log.debug("Warnings found in DSMC output: {}".format(set(warnings)))

        for warning in warnings:
            if warning not in whitelist:
                log.debug("A non-whitelisted DSMC warning was encountered. Reporting it as an error!")
                return False

        log.debug("Only whitelisted DSMC warnings were encountered. Everything is OK.")
        return True
    else:
        log.info("An uncatched DSMC error code was encountered!")
        return False

def download_from_pdc(archive, description, dest, dsmc_log_dir, whitelist):
    """
    Downloads the specified archive from PDC to a unique location. 

    :param archive: The path in PDC TSM to the archive that we want to download  
    :param description: The unique description used when previsouly uploaded the archive
    :param dest: The unique path where we shall store the downloaded archive
    :param dsmc_log_dir: Path to dir where we can save dsmc logs 
    :param whitelist: A list of dsmc warnings which we shall allow to be generated by dsmc but still count the download as successful
    :returns True if no errors or only whitelisted warnings were encountered, False otherwise 
    """
    log.debug("download_from_pdc started for {}".format(archive))
    cmd = "export DSM_LOG={} && dsmc retr {}/ {}/ -subdir=yes -description='{}'".format(dsmc_log_dir, archive, dest, description)
    log.debug("running '{}'".format(cmd))
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    dsmc_output, _ = p.communicate()
    dsmc_exit_code = p.returncode

    log.debug("returncode for '{}': {}".format(cmd, dsmc_exit_code))

    if dsmc_exit_code != 0:
        return _parse_dsmc_return_code(dsmc_exit_code, dsmc_output, whitelist)

    log.debug("download_from_pdc completed successfully for {}".format(archive))
    return True

def compare_md5sum(archive_dir):
    """
    Calculates the MD5 sums of the specified archive and compares them to the previously generated checksums 
    that were uploaded together with the archive to PDC. 

    :param archive_dir: The path to the archive that we shall verify
    :returns True if no errors or warnings were encountered when calculating checksums, otherwise False 
    """
    parent_dir = os.path.abspath(os.path.join(archive_dir, os.pardir))
    md5_output = os.path.join(parent_dir, "compare_md5sum.out")
    cmd = "cd {} && md5sum -c ./{} > {}".format(archive_dir, "checksums_prior_to_pdc.md5", md5_output)
    log.debug("running '{}'".format(cmd))
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    p.communicate()

    log.debug("returncode for '{}': {}".format(cmd, p.returncode))

    if p.returncode != 0: 
        return False
    else: 
        return True

def verify_archive(archive, archive_path, description, config):
    """
    Our main worker function. This will be put into the RQ/Redis queue when the /verify endpoint gets called. 
    Downloads the specified archive from PDC and then verifies the MD5 sums. 

    :param archive: The name of the archive we shall download
    :param archive_path: The path to the archive on PDC
    :param description: The unique description that was used when uploading the archive to PDC
    :param config: A dict containing the apps configuration
    :returns A JSON with the result that will be kept in the Redis queue
    """
    dest_root = config["verify_root_dir"]
    dsmc_log_dir = config["dsmc_log_dir"]
    whitelist = config["whitelisted_warnings"]

    now_str = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M')
    log.setLevel(logging.DEBUG)
    fh = logging.FileHandler("{}/{}-{}.log".format(dsmc_log_dir, description, now_str))
    fh.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    fh.setFormatter(formatter)
    log.addHandler(fh)

    log.debug("verify_archive started for {}".format(archive))

    job_id = rq.get_current_job().id
    dest = "{}_{}".format(os.path.join(dest_root, archive), job_id)

    download_ok = download_from_pdc(archive_path, description, dest, dsmc_log_dir, whitelist)

    log.debug("download ok: {}".format(download_ok))

    if not download_ok:
        log.debug("Download of {} failed.".format(archive))
        return {"state": "error", "msg": "failed to properly download archive from pdc", "path": dest}
    else:
        log.debug("verifying {}".format(archive))
        archive = os.path.join(dest, archive)
        verified_ok = compare_md5sum(archive)
        output_file = "{}/compare_md5sum.out".format(dest)

        if verified_ok:
            log.debug("Verify of {} succeeded.".format(archive))
            return {"state": "done", "path": output_file, "msg": "sucessfully verified archive md5sums"}
        else:
            log.debug("Verify of {} failed.".format(archive))
            return {"state": "error", "path": output_file, "msg": "failed to verify archive md5sums"}
